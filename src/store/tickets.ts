import { createAction, handleActions } from 'redux-actions'import { Dispatch } from 'redux'import { ITicket } from '../models/ticket.model'import ticketsService from '../services/tickets.service'//#region Action Typesenum ACTIONS {  TICKETS_REQUEST = 'TICKETS_REQUEST',  TICKETS_SUCCESS = 'TICKETS_SUCCESS',  TICKETS_FAILURE = 'TICKETS_FAILURE',  SEARCH_ID_REQUEST = 'SEARCH_ID_REQUEST',  SEARCH_ID_SUCCESS = 'SEARCH_ID_SUCCESS',  SEARCH_ID_FAILURE = 'SEARCH_ID_FAILURE',}//endregion//#region Actionsexport const ticketsRequest = createAction(ACTIONS.TICKETS_REQUEST)export const ticketsSuccess = createAction(  ACTIONS.TICKETS_SUCCESS,  (tickets: ITicket[], stop: boolean = true) => ({ tickets, stop }),)export const ticketsFailure = createAction(ACTIONS.TICKETS_FAILURE)export const searchIdRequest = createAction(ACTIONS.SEARCH_ID_REQUEST)export const searchIdSuccess = createAction(ACTIONS.SEARCH_ID_SUCCESS, (id: string) => ({ id }))export const searchIdFailure = createAction(ACTIONS.SEARCH_ID_FAILURE)//endregion//#region Thunksexport const getSearchIdThunk = () => async (dispatch: Dispatch) => {  dispatch(searchIdRequest())  let searchId: string | undefined;  try {    searchId = (await ticketsService.getSearchId()).searchId    dispatch(searchIdSuccess(searchId))  } catch {    dispatch(searchIdFailure())  }  return searchId}export const getTicketsThunk = (searchId: string) => async (  dispatch: any,) => {  dispatch(ticketsRequest())  try {    const { tickets, stop } = await ticketsService.getTicketsChunk(searchId)    dispatch(ticketsSuccess(tickets, stop))  } catch {    dispatch(ticketsFailure())  }}//endregion//#region Reducerexport const ticketsReducer = handleActions<ITicketsState>({  [searchIdRequest.toString()]: (state, { payload }: any) => {    return {      ...state,      searchIdLoading: true,    }  },  [searchIdSuccess.toString()]: (state, { payload }: any) => {    return {      ...state,      searchId: payload.id,      searchIdLoading: false,    }  },  [searchIdFailure.toString()]: (state, { payload }: any) => {    return {      ...state,      errors: [...state.errors, 'Search ID fetching failed'],      searchIdLoading: false,    }  },  [ticketsRequest.toString()]: (state, { payload }: any) => {    return {      ...state,      ticketsLoading: true,    }  },  [ticketsSuccess.toString()]: (state, { payload }: any) => {    return {      ...state,      data: state.data.concat(payload.tickets),      ticketsLoading: false,      stop: payload.stop,      ticketsRequestCounter: state.ticketsRequestCounter + 1,    }  },  [ticketsFailure.toString()]: (state, { payload }: any) => {    return {      ...state,      // errors: [...state.errors, 'Tickets fetching failed'],      ticketsLoading: false,      ticketsRequestCounter: state.ticketsRequestCounter + 1,    }  },}, {  data: [],  errors: [],  ticketsLoading: false,  searchIdLoading: false,  ticketsRequestCounter: 0,})//endregion//#region Modelsinterface ITicketsState {  data: ITicket[]  errors: any[]  ticketsLoading: boolean  searchIdLoading: boolean  searchId?: string | undefined  ticketsRequestCounter: number}//endregion